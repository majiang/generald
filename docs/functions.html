<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>generald.functions</title>
        </head><body>
        <h1>generald.functions</h1>
        <!-- Generated by Ddoc from source\generald\functions.d -->
This module implements a variety of classes derived from Function.<br><br>

<dl><dt><big><a name="Function"></a>class <u>Function</u>(A, B);
</big></dt>
<dd>A class representing a function.<br><br>

</dd>
<dt><big><a name="RealFunction"></a>class <u>RealFunction</u>(alias f, A = ParameterTypeTuple!f[0], B = ReturnType!f): Function!(A, B);
</big></dt>
<dd>Template for converting a function to Function instance.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>int</font> f(<font color=blue>long</font> x)
{
	<font color=blue>return</font> <font color=blue>cast</font>(<font color=blue>int</font>)((x &gt;&gt; 32) ^ (x &amp; ((1UL &lt;&lt; 32) - 1)));
}
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<u>RealFunction</u>!f : Function!(<font color=blue>long</font>, <font color=blue>int</font>)));
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<u>RealFunction</u>!(f, <font color=blue>int</font>, <font color=blue>int</font>) : Function!(<font color=blue>int</font>, <font color=blue>int</font>)));
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<u>RealFunction</u>!(f, <font color=blue>int</font>, <font color=blue>long</font>) : Function!(<font color=blue>int</font>, <font color=blue>long</font>)));
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<u>RealFunction</u>!(f, <font color=blue>long</font>, <font color=blue>long</font>) : Function!(<font color=blue>long</font>, <font color=blue>long</font>)));
</pre>
<br><br>
</dd>
<dt><big><a name="id"></a>T <u>id</u>(T)(T <i>x</i>);
<br><a name="IdentityFunction"></a>template <u>IdentityFunction</u>(T)</big></dt>
<dd>Identity function.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> f = <u>IdentityFunction</u>!<font color=blue>int</font>.get;
<font color=blue>assert</font> (f(0) == 0);
</pre>
<br><br>
</dd>
<dt><big><a name="ComposedFunction"></a>class <u>ComposedFunction</u>(A, B, C, D) if (is(B : C)): Function!(A, D);
<br><a name="compose"></a>auto <u>compose</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F : Function!(F.InputType, F.OutputType)) &amp;&amp; is(G : Function!(G.InputType, G.OutputType)) &amp;&amp; is(F.OutputType : G.InputType));
</big></dt>
<dd>Compose two Functions.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> f = RealFunction!(triple!<font color=blue>int</font>).get.<u>compose</u>(RealFunction!(increment!<font color=blue>int</font>).get);
<font color=blue>auto</font> g = RealFunction!(increment!<font color=blue>int</font>).get.<u>compose</u>(RealFunction!(triple!<font color=blue>int</font>).get);
<font color=blue>assert</font> (f(0) == 1);
<font color=blue>assert</font> (f(1) == 4);
<font color=blue>assert</font> (g(0) == 3);
<font color=blue>assert</font> (g(1) == 6);
</pre>
<br><br>
</dd>
<dt><big><a name="CurriedFunction"></a>class <u>CurriedFunction</u>(A, B, C): Function!(A, Function!(B, C));
<br><a name="curry"></a>auto <u>curry</u>(F)(F <i>f</i>);
</big></dt>
<dd>Curry a function.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>class</font> F : Function!(Tuple!(<font color=blue>int</font>, <font color=blue>int</font>), <font color=blue>int</font>)
{
	<font color=blue>override</font> <font color=blue>int</font> opCall(Tuple!(<font color=blue>int</font>, <font color=blue>int</font>) x)
	{
		<font color=blue>return</font> x[0] + x[1];
	}
	<font color=blue>mixin</font> Singleton;
}
<font color=blue>auto</font> cf = F.get.<u>curry</u>;
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (cf) : Function!(<font color=blue>int</font>, Function!(<font color=blue>int</font>, <font color=blue>int</font>))));
</pre>
<br><br>
</dd>
<dt><big><a name="UncurriedFunction"></a>class <u>UncurriedFunction</u>(A, B, C): Function!(Tuple!(A, B), C);
<br><a name="uncurry"></a>auto <u>uncurry</u>(F)(F <i>f</i>);
</big></dt>
<dd>Uncurry a function.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>class</font> G : Function!(<font color=blue>int</font>, Function!(<font color=blue>int</font>, <font color=blue>int</font>))
{

	<font color=blue>class</font> g : Function!(<font color=blue>int</font>, <font color=blue>int</font>)
	{
		<font color=blue>int</font> x;
		<font color=blue>this</font> (<font color=blue>int</font> x)
		{
			<font color=blue>this</font>.x = x;
		}
		<font color=blue>override</font> <font color=blue>int</font> opCall(<font color=blue>int</font> x)
		{
			<font color=blue>return</font> <font color=blue>this</font>.x + x;
		}
	}
	<font color=blue>override</font> Function!(<font color=blue>int</font>, <font color=blue>int</font>) opCall(<font color=blue>int</font> x)
	{
		<font color=blue>return</font> <font color=blue>new</font> g(x);
	}
	<font color=blue>mixin</font> Singleton;
}
<font color=blue>auto</font> ug = G.get.<u>uncurry</u>;
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (ug) : Function!(Tuple!(<font color=blue>int</font>, <font color=blue>int</font>), <font color=blue>int</font>)));
</pre>
<br><br>
</dd>
<dt><big><a name="MaybeReturn"></a>template <u>MaybeReturn</u>(A)</big></dt>
<dd>Return function for Maybe.<br><br>

</dd>
<dt><big><a name="MaybeBind"></a>class <u>MaybeBind</u>(A, B): Function!(Maybe!A, Maybe!B);
<br><a name="maybeBind"></a>auto <u>maybeBind</u>(F)(F <i>f</i>);
</big></dt>
<dd>Bind function for Maybe: (a -&gt; Maybe b) -&gt; (Maybe a -&gt; Maybe b).<br><br>

</dd>
<dt><big><a name="maybeMap"></a>auto <u>maybeMap</u>(F)(F <i>f</i>) if (is(F : Function!(A, B), A, B));
</big></dt>
<dd>Map function for Maybe.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> maybeId = <u>maybeMap</u>(RealFunction!(id!<font color=blue>int</font>).get);
<font color=blue>assert</font> (maybeId(just(0)) == just(0));
</pre>
<br><br>
</dd>
<dt><big><a name="maybeCompose"></a>auto <u>maybeCompose</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Compose two Functions f and g where f emits a Maybe!B and g takes a B.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> c = RealFunction!(collatz!<font color=blue>int</font>).get;
<font color=blue>auto</font> lc = c.<u>maybeCompose</u>(c).<u>maybeCompose</u>(c);
<font color=blue>auto</font> rc = c.<u>maybeCompose</u>(c.<u>maybeCompose</u>(c));
<font color=blue>foreach</font> (i; 0..10)
	<font color=blue>assert</font> (lc(i).maybeEqual(rc(i)));
</pre>
<br><br>
</dd>
<dt><big><a name="MaybeSink"></a>class <u>MaybeSink</u>(A): Function!(Maybe!A, void);
<br><a name="maybeSink"></a>auto <u>maybeSink</u>(S)(S <i>sink</i>) if (is(S : Function!(A, void), A));
</big></dt>
<dd>Function from Maybe to void can be constructed from a Function to void.<br><br>

</dd>
<dt><big><a name="MaybeNothing"></a>class <u>MaybeNothing</u>(A, B, C = void): Function!(A, Maybe!B);
<br><a name="maybeNothing"></a>auto <u>maybeNothing</u>(B, F)(F <i>f</i>);
</big></dt>
<dd>Maybe do something, and return <b>null</b>.<br><br>

</dd>
<dt><big><a name="Either"></a>struct <u>Either</u>(A, B) if (!is(A : B) &amp;&amp; !is(B : A));
</big></dt>
<dd><u>Either</u> type.<br><br>

</dd>
<dt><big><a name="EitherFunction"></a>class <u>EitherFunction</u>(A, B, C): Function!(Either!(A, B), C);
<br><a name="eitherFunction"></a>auto <u>eitherFunction</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F.OutputType == G.OutputType));
</big></dt>
<dd>Tuple of functions, which takes an Either.<br><br>

</dd>
<dt><big><a name="LeftEither"></a>template <u>LeftEither</u>(A, B)<br><a name="RightEither"></a>template <u>RightEither</u>(A, B)</big></dt>
<dd>Function to Either.<br><br>

</dd>
<dt><big><a name="left"></a>Either!(A, B) <u>left</u>(B, A)(A <i>a</i>);
</big></dt>
<dd>Either!(, B) functor at A.<br><br>

</dd>
<dt><big><a name="right"></a>Either!(A, B) <u>right</u>(A, B)(B <i>b</i>);
</big></dt>
<dd>Either!(A, ) functor at B.<br><br>

</dd>
<dt><big><a name="eitherEither"></a>auto <u>eitherEither</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Function from and to Either.<br><br>

</dd>
<dt><big><a name="FunctionTuple"></a>class <u>FunctionTuple</u>(A, B, C): Function!(A, Tuple!(B, C));
<br><a name="functionTuple"></a>auto <u>functionTuple</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F.InputType == G.InputType));
</big></dt>
<dd>Tuple of functions, which returns a Tuple.<br><br>

</dd>
<dt><big><a name="tupleLeft"></a>auto <u>tupleLeft</u>(T)(T <i>x</i>);
<br><a name="tupleRight"></a>auto <u>tupleRight</u>(T)(T <i>x</i>);
<br><a name="TupleLeft"></a>template <u>TupleLeft</u>(A, B)<br><a name="TupleRight"></a>template <u>TupleRight</u>(A, B)</big></dt>
<dd>Function from Tuple.<br><br>

</dd>
<dt><big><a name="tupleTuple"></a>auto <u>tupleTuple</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Function from and to Tuple.<br><br>

</dd>
<dt><big><a name="maybeTuple"></a>auto <u>maybeTuple</u>(TM)(TM <i>x</i>);
<br><a name="MaybeTuple"></a>template <u>MaybeTuple</u>(A, B)</big></dt>
<dd>Function from Tuple of Maybe to Maybe of Tuple.<br><br>

</dd>
<dt><big><a name="swapper"></a>auto <u>swapper</u>(A, B)();
</big></dt>
<dd>Returns the function which swaps the components of the given tuple.<br><br>

</dd>
<dt><big><a name="swapResult"></a>auto <u>swapResult</u>(F)(F <i>f</i>);
</big></dt>
<dd>Compose with swapper.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = <font color=blue>new</font> Maybe!<font color=blue>int</font>[4];
<font color=blue>auto</font> y = <font color=blue>new</font> Maybe!<font color=blue>int</font>[4];
<font color=blue>auto</font> z = <font color=blue>new</font> Maybe!(Tuple!(<font color=blue>int</font>, <font color=blue>int</font>))[4];
x[0] = 2; x[1] = 3;
y[0] = 5, y[2] = 7;
z[0] = 5.tuple(2);
<font color=blue>auto</font> p = IdentityFunction!(Tuple!(Maybe!<font color=blue>int</font>, Maybe!<font color=blue>int</font>)).get
.<u>swapResult</u>.compose(MaybeTuple!(<font color=blue>int</font>, <font color=blue>int</font>).get);
<font color=blue>foreach</font> (i; 0..4)
	<font color=blue>assert</font> (p(x[i].tuple(y[i])).maybeEqual(z[i]));
</pre>
<br><br>
</dd>
<dt><big><a name="functionTupleIdentity"></a>auto <u>functionTupleIdentity</u>(F)(F <i>f</i>);
</big></dt>
<dd>(a -&gt; b) -&gt; (a -&gt; (b, a))<br><br>

</dd>
<dt><big><a name="tupleTupleIdentity"></a>auto <u>tupleTupleIdentity</u>(B, F)(F <i>f</i>);
</big></dt>
<dd>(a -&gt; b) -&gt; ((a, c) -&gt; (b, c))<br><br>

</dd>
<dt><big><a name="eitherFunctionIdentity"></a>auto <u>eitherFunctionIdentity</u>(F)(F <i>f</i>);
</big></dt>
<dd>(a -&gt; b) -&gt; (a|b -&gt; b)<br><br>

</dd>
<dt><big><a name="eitherEitherIdentity"></a>auto <u>eitherEitherIdentity</u>(B, F)(F <i>f</i>);
</big></dt>
<dd>(a -&gt; b) -&gt; (a|c -&gt; b|c)<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>class</font> TestedFunction : Function!(<font color=blue>int</font>, string)
{
	<font color=blue>override</font> string opCall(<font color=blue>int</font> x)
	{
		<font color=blue>import</font> std.math, std.conv;
		<font color=blue>return</font> sqrt(<font color=blue>real</font>(1) + x * x).to!string;
	}
	<font color=blue>mixin</font> Singleton;
}
<font color=blue>auto</font> t = TestedFunction.get;
<font color=blue>auto</font>
	t0 = t.functionTupleIdentity,
	t1 = t.tupleTupleIdentity!(<font color=blue>int</font>[]),
	t2 = t.eitherFunctionIdentity,
	t3 = t.<u>eitherEitherIdentity</u>!(<font color=blue>int</font>[]);
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (t0) : Function!(<font color=blue>int</font>, Tuple!(string, <font color=blue>int</font>))));
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (t1) : Function!(Tuple!(<font color=blue>int</font>, <font color=blue>int</font>[]), Tuple!(string, <font color=blue>int</font>[]))));
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (t2) : Function!(Either!(<font color=blue>int</font>, string), string)));
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (t3) : Function!(Either!(<font color=blue>int</font>, <font color=blue>int</font>[]), Either!(string, <font color=blue>int</font>[]))));
</pre>
<br><br>
</dd>
<dt><big><a name="FunctionEither"></a>class <u>FunctionEither</u>(A, B, C): Function!(A, Either!(B, C));
<br><a name="functionEitherLeft"></a>auto <u>functionEitherLeft</u>(C, F)(F <i>f</i>);
<br><a name="functionEitherRight"></a>auto <u>functionEitherRight</u>(B, F)(F <i>f</i>);
</big></dt>
<dd>Either of functions, which returns an Either.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>real</font> lreal(<font color=blue>int</font> x)
{
	<font color=blue>import</font> std.math;
	<font color=blue>return</font> PI * x;
}
<font color=blue>static</font> string rstring(<font color=blue>int</font> x)
{
	<font color=blue>import</font> std.conv;
	<font color=blue>return</font> x.to!string;
}
<font color=blue>auto</font> fl = RealFunction!lreal.get.functionEitherLeft!string;
<font color=blue>auto</font> fr = RealFunction!rstring.get.<u>functionEitherRight</u>!<font color=blue>real</font>;
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (fl) == <font color=blue>typeof</font> (fr)));
</pre>
<br><br>
</dd>
<dt><big><a name="TupleFunction"></a>class <u>TupleFunction</u>(A, B, C): Function!(Tuple!(A, B), C);
<br><a name="leftTupleFunction"></a>auto <u>leftTupleFunction</u>(B, F)(F <i>f</i>);
<br><a name="rightTupleFunction"></a>auto <u>rightTupleFunction</u>(A, F)(F <i>f</i>);
</big></dt>
<dd>Either of functions, which takes a Tuple.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> string cts(<font color=blue>char</font> x)
{
	<font color=blue>import</font> std.conv : to;
	<font color=blue>return</font> x.to!string;
}
<font color=blue>static</font> string rts(<font color=blue>real</font> x)
{
	<font color=blue>import</font> std.conv : to;
	<font color=blue>return</font> x.to!string;
}
<font color=blue>auto</font> l = RealFunction!cts.get.leftTupleFunction!<font color=blue>real</font>;
<font color=blue>auto</font> r = RealFunction!rts.get.<u>rightTupleFunction</u>!<font color=blue>char</font>;
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (l) == <font color=blue>typeof</font> (r)));
</pre>
<br><br>
</dd>
<dt><big><a name="FunctionArray"></a>class <u>FunctionArray</u>(A, B): Function!(A, B[]);
<br><a name="functionArray"></a>auto <u>functionArray</u>(F)(F[] <i>fs</i>);
</big></dt>
<dd>Takues an array of functions and return a function to array.<br><br>

</dd>
<dt><big><a name="ArrayMap"></a>class <u>ArrayMap</u>(A, B): Function!(A[], B[]);
<br><a name="arrayMap"></a>auto <u>arrayMap</u>(F)(F <i>f</i>);
</big></dt>
<dd>Map function for Array.<br><br>

</dd>
<dt><big><a name="ArrayBind"></a>class <u>ArrayBind</u>(A, B): Function!(A[], B[]);
<br><a name="arrayBind"></a>auto <u>arrayBind</u>(F)(F <i>f</i>);
</big></dt>
<dd>Bind function for Array.<br><br>

</dd>
<dt><big><a name="arrayOnly"></a>auto <u>arrayOnly</u>(A)(A <i>x</i>);
<br><a name="ArrayReturn"></a>template <u>ArrayReturn</u>(A)</big></dt>
<dd>Return function for Array.<br><br>

</dd>
<dt><big><a name="Singleton"></a>template <u>Singleton</u>(Flag!"hideConstructor" hideConstructor = Yes.hideConstructor)</big></dt>
<dd><u>Singleton</u> pattern.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
