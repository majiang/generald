<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>generald.functions</title>
        </head><body>
        <h1>generald.functions</h1>
        <!-- Generated by Ddoc from source\generald\functions.d -->
This module implements a variety of classes derived from Function.<br><br>

<dl><dt><big><a name="Function"></a>class <u>Function</u>(A, B);
</big></dt>
<dd>A class representing a function.<br><br>

</dd>
<dt><big><a name="RealFunction"></a>class <u>RealFunction</u>(alias f, A = ParameterTypeTuple!f[0], B = ReturnType!f): Function!(A, B);
</big></dt>
<dd>Template for converting a function to Function instance.<br><br>

</dd>
<dt><big><a name="IdentityFunction"></a>class <u>IdentityFunction</u>(T): Function!(T, T);
</big></dt>
<dd><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> f = RealFunction!(id!<font color=blue>int</font>).get;
<font color=blue>assert</font> (f(0) == 0);
</pre>
<br><br>
</dd>
<dt><big><a name="ComposedFunction"></a>class <u>ComposedFunction</u>(A, B, C, D) if (is(B : C)): Function!(A, D);
<br><a name="compose"></a>auto <u>compose</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F : Function!(F.InputType, F.OutputType)) &amp;&amp; is(G : Function!(G.InputType, G.OutputType)) &amp;&amp; is(F.OutputType : G.InputType));
</big></dt>
<dd>Compose two Functions.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> f = RealFunction!(triple!<font color=blue>int</font>).get.<u>compose</u>(RealFunction!(increment!<font color=blue>int</font>).get);
<font color=blue>auto</font> g = RealFunction!(increment!<font color=blue>int</font>).get.<u>compose</u>(RealFunction!(triple!<font color=blue>int</font>).get);
<font color=blue>assert</font> (f(0) == 1);
<font color=blue>assert</font> (f(1) == 4);
<font color=blue>assert</font> (g(0) == 3);
<font color=blue>assert</font> (g(1) == 6);
</pre>
<br><br>
</dd>
<dt><big><a name="MaybeReturn"></a>class <u>MaybeReturn</u>(A): Function!(A, Maybe!A);
</big></dt>
<dd>Return function for Maybe.<br><br>

</dd>
<dt><big><a name="MaybeBind"></a>class <u>MaybeBind</u>(A, B): Function!(Maybe!A, Maybe!B);
<br><a name="maybeBind"></a>auto <u>maybeBind</u>(F)(F <i>f</i>);
</big></dt>
<dd>Bind function for Maybe: (a -&gt; Maybe b) -&gt; (Maybe a -&gt; Maybe b).<br><br>

</dd>
<dt><big><a name="maybeMap"></a>auto <u>maybeMap</u>(F)(F <i>f</i>) if (is(F : Function!(A, B), A, B));
</big></dt>
<dd>fmap function for Maybe.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> maybeId = <u>maybeMap</u>(RealFunction!(id!<font color=blue>int</font>).get);
<font color=blue>assert</font> (maybeId(Maybe!<font color=blue>int</font>(0)) == Maybe!<font color=blue>int</font>(0));
</pre>
<br><br>
</dd>
<dt><big><a name="maybeCompose"></a>auto <u>maybeCompose</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Compose two Functions f and g where f emits a Maybe!B and g takes a B.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> c = RealFunction!(collatz!<font color=blue>int</font>).get;
<font color=blue>auto</font> lc = c.<u>maybeCompose</u>(c).<u>maybeCompose</u>(c);
<font color=blue>auto</font> rc = c.<u>maybeCompose</u>(c.<u>maybeCompose</u>(c));
<font color=blue>foreach</font> (i; 0..10)
	<font color=blue>assert</font> (lc(i).maybeEqual(rc(i)));
</pre>
<br><br>
</dd>
<dt><big><a name="MaybeSink"></a>class <u>MaybeSink</u>(A): Function!(Maybe!A, void);
<br><a name="maybeSink"></a>auto <u>maybeSink</u>(S)(S <i>sink</i>) if (is(S : Function!(A, void), A));
</big></dt>
<dd>Function from Maybe to void can be constructed from a Function to void.<br><br>

</dd>
<dt><big><a name="MaybeNothing"></a>class <u>MaybeNothing</u>(A, B, C = void): Function!(A, Maybe!B);
<br><a name="maybeNothing"></a>auto <u>maybeNothing</u>(B, F)(F <i>f</i>);
</big></dt>
<dd>Maybe do something, and return <b>null</b>.<br><br>

</dd>
<dt><big><a name="Either"></a>struct <u>Either</u>(A, B) if (!is(A : B) &amp;&amp; !is(B : A));
</big></dt>
<dd><u>Either</u> type.<br><br>

</dd>
<dt><big><a name="EitherFunction"></a>class <u>EitherFunction</u>(A, B, C): Function!(Either!(A, B), C);
<br><a name="eitherFunction"></a>auto <u>eitherFunction</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F.OutputType == G.OutputType));
</big></dt>
<dd>Function from either.<br><br>

</dd>
<dt><big><a name="LeftEither"></a>template <u>LeftEither</u>(A, B)<br><a name="RightEither"></a>template <u>RightEither</u>(A, B)</big></dt>
<dd>Function to Either.<br><br>

</dd>
<dt><big><a name="left"></a>Either!(A, B) <u>left</u>(B, A)(A <i>a</i>);
</big></dt>
<dd>Either!(, B) functor at A.<br><br>

</dd>
<dt><big><a name="right"></a>Either!(A, B) <u>right</u>(A, B)(B <i>b</i>);
</big></dt>
<dd>Either!(A, ) functor at B.<br><br>

</dd>
<dt><big><a name="eitherEither"></a>auto <u>eitherEither</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Function from and to Either.<br><br>

</dd>
<dt><big><a name="FunctionTuple"></a>class <u>FunctionTuple</u>(A, B, C): Function!(A, Tuple!(B, C));
<br><a name="functionTuple"></a>auto <u>functionTuple</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F.InputType == G.InputType));
</big></dt>
<dd>Function to Tuple.<br><br>

</dd>
<dt><big><a name="TupleLeft"></a>class <u>TupleLeft</u>(A, B): Function!(Tuple!(A, B), A);
<br><a name="TupleRight"></a>class <u>TupleRight</u>(A, B): Function!(Tuple!(A, B), B);
</big></dt>
<dd>Function from Tuple.<br><br>

</dd>
<dt><big><a name="tupleTuple"></a>auto <u>tupleTuple</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Function from and to Tuple.<br><br>

</dd>
<dt><big><a name="MaybeTuple"></a>class <u>MaybeTuple</u>(A, B): Function!(Tuple!(Maybe!A, Maybe!B), Maybe!(Tuple!(A, B)));
</big></dt>
<dd>Function from Tuple of Maybe to Maybe of Tuple.<br><br>

</dd>
<dt><big><a name="swapper"></a>auto <u>swapper</u>(A, B)();
</big></dt>
<dd>Returns the function which swaps the components of the given tuple.<br><br>

</dd>
<dt><big><a name="swapResult"></a>auto <u>swapResult</u>(F)(F <i>f</i>);
</big></dt>
<dd>Compose with swapper.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = <font color=blue>new</font> Maybe!<font color=blue>int</font>[4];
<font color=blue>auto</font> y = <font color=blue>new</font> Maybe!<font color=blue>int</font>[4];
<font color=blue>auto</font> z = <font color=blue>new</font> Maybe!(Tuple!(<font color=blue>int</font>, <font color=blue>int</font>))[4];
x[0] = 2; x[1] = 3;
y[0] = 5, y[2] = 7;
z[0] = 5.tuple(2);
<font color=blue>auto</font> p = IdentityFunction!(Tuple!(Maybe!<font color=blue>int</font>, Maybe!<font color=blue>int</font>)).get
.<u>swapResult</u>.compose(MaybeTuple!(<font color=blue>int</font>, <font color=blue>int</font>).get);
<font color=blue>foreach</font> (i; 0..4)
	<font color=blue>assert</font> (p(x[i].tuple(y[i])).maybeEqual(z[i]));
</pre>
<br><br>
</dd>
<dt><big><a name="functionTupleIdentity"></a>auto <u>functionTupleIdentity</u>(F)(F <i>f</i>);
</big></dt>
<dd>(a -&gt; b) -&gt; (a -&gt; (b, a))<br><br>

</dd>
<dt><big><a name="tupleTupleIdentity"></a>auto <u>tupleTupleIdentity</u>(B, F)(F <i>f</i>);
</big></dt>
<dd>(a -&gt; b) -&gt; ((a, c) -&gt; (b, c))<br><br>

</dd>
<dt><big><a name="eitherFunctionIdentity"></a>auto <u>eitherFunctionIdentity</u>(F)(F <i>f</i>);
</big></dt>
<dd>(a -&gt; b) -&gt; (a|b -&gt; b)<br><br>

</dd>
<dt><big><a name="eitherEitherIdentity"></a>auto <u>eitherEitherIdentity</u>(B, F)(F <i>f</i>);
</big></dt>
<dd>(a -&gt; b) -&gt; (a|c -&gt; b|c)<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// a = int, b = string, c = int[]
</font><font color=blue>static</font> <font color=blue>class</font> TestedFunction : Function!(<font color=blue>int</font>, string)
{
	<font color=blue>override</font> string opCall(<font color=blue>int</font> x)
	{
		<font color=blue>import</font> std.math, std.conv;
		<font color=blue>return</font> sqrt(<font color=blue>real</font>(1) + x * x).to!string;
	}
	<font color=blue>mixin</font> Singleton;
}
<font color=blue>auto</font> t = TestedFunction.get;
<font color=blue>auto</font>
	t0 = t.functionTupleIdentity,
	t1 = t.tupleTupleIdentity!(<font color=blue>int</font>[]),
	t2 = t.eitherFunctionIdentity,
	t3 = t.<u>eitherEitherIdentity</u>!(<font color=blue>int</font>[]);
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (t0) : Function!(<font color=blue>int</font>, Tuple!(string, <font color=blue>int</font>))));
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (t1) : Function!(Tuple!(<font color=blue>int</font>, <font color=blue>int</font>[]), Tuple!(string, <font color=blue>int</font>[]))));
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (t2) : Function!(Either!(<font color=blue>int</font>, string), string)));
<font color=blue>static</font> <font color=blue>assert</font> (<font color=blue>is</font> (<font color=blue>typeof</font> (t3) : Function!(Either!(<font color=blue>int</font>, <font color=blue>int</font>[]), Either!(string, <font color=blue>int</font>[]))));
</pre>
<br><br>
</dd>
<dt><big><a name="Singleton"></a>template <u>Singleton</u>(Flag!"hideConstructor" hideConstructor = Yes.hideConstructor)</big></dt>
<dd><u>Singleton</u> pattern.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
