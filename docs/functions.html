<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>generald.functions</title>
        </head><body>
        <h1>generald.functions</h1>
        <!-- Generated by Ddoc from source\generald\functions.d -->
This module implements a variety of classes derived from Function.<br><br>

<dl><dt><big><a name="Function"></a>class <u>Function</u>(A, B);
</big></dt>
<dd>A class representing a function.<br><br>

</dd>
<dt><big><a name="RealFunction"></a>class <u>RealFunction</u>(alias f, A = ParameterTypeTuple!f[0], B = ReturnType!f): Function!(A, B);
</big></dt>
<dd>Template for converting a function to Function instance.<br><br>

</dd>
<dt><big><a name="IdentityFunction"></a>class <u>IdentityFunction</u>(T): Function!(T, T);
</big></dt>
<dd><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> f = RealFunction!(id!<font color=blue>int</font>).get;
<font color=blue>assert</font> (f(0) == 0);
</pre>
<br><br>
</dd>
<dt><big><a name="ComposedFunction"></a>class <u>ComposedFunction</u>(A, B, C, D) if (is(B : C)): Function!(A, D);
<br><a name="compose"></a>auto <u>compose</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F : Function!(F.InputType, F.OutputType)) &amp;&amp; is(G : Function!(G.InputType, G.OutputType)) &amp;&amp; is(F.OutputType : G.InputType));
</big></dt>
<dd>Compose two Functions.<br><br>

</dd>
<dt><big><a name="MaybeReturn"></a>class <u>MaybeReturn</u>(A): Function!(A, Maybe!A);
</big></dt>
<dd>Return function for Maybe.<br><br>

</dd>
<dt><big><a name="MaybeBind"></a>class <u>MaybeBind</u>(A, B): Function!(Maybe!A, Maybe!B);
<br><a name="maybeBind"></a>auto <u>maybeBind</u>(F)(F <i>f</i>);
</big></dt>
<dd>Bind function for Maybe: (a -&gt; Maybe b) -&gt; (Maybe a -&gt; Maybe b).<br><br>

</dd>
<dt><big><a name="maybeMap"></a>auto <u>maybeMap</u>(F)(F <i>f</i>) if (is(F : Function!(A, B), A, B));
</big></dt>
<dd>fmap function for Maybe.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> maybeId = <u>maybeMap</u>(RealFunction!(id!<font color=blue>int</font>).get);
<font color=blue>assert</font> (maybeId(Maybe!<font color=blue>int</font>(0)) == Maybe!<font color=blue>int</font>(0));
</pre>
<br><br>
</dd>
<dt><big><a name="maybeCompose"></a>auto <u>maybeCompose</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Compose two Functions f and g where f emits a Maybe!B and g takes a B.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> c = RealFunction!(collatz!<font color=blue>int</font>).get;
<font color=blue>auto</font> lc = c.<u>maybeCompose</u>(c).<u>maybeCompose</u>(c);
<font color=blue>auto</font> rc = c.<u>maybeCompose</u>(c.<u>maybeCompose</u>(c));
<font color=blue>foreach</font> (i; 0..10)
	<font color=blue>assert</font> (lc(i).maybeEqual(rc(i)));
</pre>
<br><br>
</dd>
<dt><big><a name="MaybeSink"></a>class <u>MaybeSink</u>(A): Function!(Maybe!A, void);
<br><a name="maybeSink"></a>auto <u>maybeSink</u>(S)(S <i>sink</i>) if (is(S : Function!(A, void), A));
</big></dt>
<dd>Function from Maybe to void can be constructed from a Function to void.<br><br>

</dd>
<dt><big><a name="MaybeNothing"></a>class <u>MaybeNothing</u>(A, B, C = void): Function!(A, Maybe!B);
<br><a name="maybeNothing"></a>auto <u>maybeNothing</u>(B, F)(F <i>f</i>);
</big></dt>
<dd>Maybe do something, and return <b>null</b>.<br><br>

</dd>
<dt><big><a name="Either"></a>struct <u>Either</u>(A, B) if (!is(A : B) &amp;&amp; !is(B : A));
</big></dt>
<dd><u>Either</u> type.<br><br>

</dd>
<dt><big><a name="EitherFunction"></a>class <u>EitherFunction</u>(A, B, C): Function!(Either!(A, B), C);
<br><a name="eitherFunction"></a>auto <u>eitherFunction</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F.OutputType == G.OutputType));
</big></dt>
<dd>Function from either.<br><br>

</dd>
<dt><big><a name="LeftEither"></a>template <u>LeftEither</u>(A, B)<br><a name="RightEither"></a>template <u>RightEither</u>(A, B)</big></dt>
<dd>Function to Either.<br><br>

</dd>
<dt><big><a name="left"></a>Either!(A, B) <u>left</u>(B, A)(A <i>a</i>);
</big></dt>
<dd>Either!(, B) functor at A.<br><br>

</dd>
<dt><big><a name="right"></a>Either!(A, B) <u>right</u>(A, B)(B <i>b</i>);
</big></dt>
<dd>Either!(A, ) functor at B.<br><br>

</dd>
<dt><big><a name="eitherEither"></a>auto <u>eitherEither</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Function from and to Either.<br><br>

</dd>
<dt><big><a name="FunctionTuple"></a>class <u>FunctionTuple</u>(A, B, C): Function!(A, Tuple!(B, C));
<br><a name="functionTuple"></a>auto <u>functionTuple</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F.InputType == G.InputType));
</big></dt>
<dd>Function to Tuple.<br><br>

</dd>
<dt><big><a name="TupleLeft"></a>class <u>TupleLeft</u>(A, B): Function!(Tuple!(A, B), A);
<br><a name="TupleRight"></a>class <u>TupleRight</u>(A, B): Function!(Tuple!(A, B), B);
</big></dt>
<dd>Function from Tuple.<br><br>

</dd>
<dt><big><a name="tupleTuple"></a>auto <u>tupleTuple</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Function from and to Tuple.<br><br>

</dd>
<dt><big><a name="MaybeTuple"></a>class <u>MaybeTuple</u>(A, B): Function!(Tuple!(Maybe!A, Maybe!B), Maybe!(Tuple!(A, B)));
</big></dt>
<dd>Function from Tuple of Maybe to Maybe of Tuple.<br><br>

</dd>
<dt><big><a name="swapper"></a>auto <u>swapper</u>(A, B)();
</big></dt>
<dd>Returns the function which swaps the components of the given tuple.<br><br>

</dd>
<dt><big><a name="swapResult"></a>auto <u>swapResult</u>(F)(F <i>f</i>);
</big></dt>
<dd>Compose with swapper.<br><br>

</dd>
<dt><big><a name="Singleton"></a>template <u>Singleton</u>(Flag!"hideConstructor" hideConstructor = Yes.hideConstructor)</big></dt>
<dd><u>Singleton</u> pattern.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
