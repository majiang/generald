<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>generald.generald</title>
        </head><body>
        <h1>generald.generald</h1>
        <!-- Generated by Ddoc from source\generald\generald.d -->
<br><br>
<dl><dt><big><a name="Function"></a>class <u>Function</u>(A, B);
</big></dt>
<dd>A class representing a function.<br><br>

</dd>
<dt><big><a name="RealFunction"></a>class <u>RealFunction</u>(alias f, A = ParameterTypeTuple!f[0], B = ReturnType!f): Function!(A, B);
</big></dt>
<dd>Template for converting a function to Function instance.<br><br>

</dd>
<dt><big><a name="MaybeSink"></a>class <u>MaybeSink</u>(A): Function!(Maybe!A, void);
<br><a name="maybeSink"></a>auto <u>maybeSink</u>(S)(S <i>sink</i>) if (is(S : Function!(A, void), A));
</big></dt>
<dd>Function from Maybe to void can be constructed from a Function to void.<br><br>

</dd>
<dt><big><a name="ComposedFunction"></a>class <u>ComposedFunction</u>(A, B, C, D) if (is(B : C)): Function!(A, D);
<br><a name="compose"></a>auto <u>compose</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F : Function!(F.InputType, F.OutputType)) &amp;&amp; is(G : Function!(G.InputType, G.OutputType)) &amp;&amp; is(F.OutputType : G.InputType));
</big></dt>
<dd>Compose two Functions.<br><br>

</dd>
<dt><big><a name="MaybeReturn"></a>class <u>MaybeReturn</u>(A): Function!(A, Maybe!A);
</big></dt>
<dd>Return function for Maybe.<br><br>

</dd>
<dt><big><a name="MaybeBind"></a>class <u>MaybeBind</u>(A, B): Function!(Maybe!A, Maybe!B);
<br><a name="maybeBind"></a>auto <u>maybeBind</u>(F)(F <i>f</i>);
</big></dt>
<dd>Bind function for Maybe.<br><br>

</dd>
<dt><big><a name="maybeMap"></a>auto <u>maybeMap</u>(F)(F <i>f</i>) if (is(F : Function!(A, B), A, B));
</big></dt>
<dd>fmap function for Maybe.<br><br>

</dd>
<dt><big><a name="Either"></a>struct <u>Either</u>(A, B) if (!is(A : B) &amp;&amp; !is(B : A));
</big></dt>
<dd><u>Either</u> type.<br><br>

</dd>
<dt><big><a name="EitherFunction"></a>class <u>EitherFunction</u>(A, B, C): Function!(Either!(A, B), C);
<br><a name="eitherFunction"></a>auto <u>eitherFunction</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F.OutputType == G.OutputType));
</big></dt>
<dd>Function from either.<br><br>

</dd>
<dt><big><a name="LeftEither"></a>class <u>LeftEither</u>(A, B): Function!(A, Either!(A, B));
<br><a name="RightEither"></a>class <u>RightEither</u>(A, B): Function!(B, Either!(A, B));
</big></dt>
<dd>Function to Either.<br><br>

</dd>
<dt><big><a name="eitherEither"></a>auto <u>eitherEither</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Function from and to Either.<br><br>

</dd>
<dt><big><a name="FunctionTuple"></a>class <u>FunctionTuple</u>(A, B, C): Function!(A, Tuple!(B, C));
<br><a name="functionTuple"></a>auto <u>functionTuple</u>(F, G)(F <i>f</i>, G <i>g</i>) if (is(F.InputType == G.InputType));
</big></dt>
<dd>Function to Tuple.<br><br>

</dd>
<dt><big><a name="TupleLeft"></a>class <u>TupleLeft</u>(A, B): Function!(Tuple!(A, B), A);
<br><a name="TupleRight"></a>class <u>TupleRight</u>(A, B): Function!(Tuple!(A, B), A);
</big></dt>
<dd>Function from Tuple.<br><br>

</dd>
<dt><big><a name="tupleTuple"></a>auto <u>tupleTuple</u>(F, G)(F <i>f</i>, G <i>g</i>);
</big></dt>
<dd>Function from and to Tuple.<br><br>

</dd>
<dt><big><a name="Singleton"></a>template <u>Singleton</u>(Flag!"hideConstructor" hideConstructor = Yes.hideConstructor)</big></dt>
<dd><u>Singleton</u> pattern.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
